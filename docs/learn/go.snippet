
	 v  	${1} := ${2}
	 vr 	var ${1:t} ${0:string}
	 var	var ${1} ${2} = ${3}
	 vars	var (
	 ap 	append(${1:slice}, ${0:value})
	 bl 	bool
	 bt		byte
	 br 	break
	 ch 	chan ${0:int}
	 cs 	case ${1:value}:
	 c		const ${1:NAME} = ${0:0}
	 co 	const (
	 cn 	continue
	 df 	defer ${0:func}()
	 dfr	defer func() {
	 i		int
	 im 	import (
	 in 	interface{}
	 inf	interface ${1:name} {
	 if 	if ${1:/* condition */} {
	 el 	else {
	 ir 	if err != nil {
	 f		false
	 ft 	fallthrough
	 fl 	float32
	 f3 	float32
	 f6 	float64
	 ie 	if else
	 fo 	for := 0; < ; {
	 fr 	for := range  {
	 fun	func ${1:funcName}(${2}) ${3:error} {
	 fum	func (self ${1:type}) ${2:funcName}(${3}) ${4:error} {
	 lf 	log.Printf("%${1:s}", ${2:var})
	 lp 	log.Println("${1}")
	 mk 	make(${1:[]string}, ${0:0})
	 mp 	map[${1:string}]${0:int}
	 main	func main() {
	 nw 	new(${0:type})
	 pn 	panic("${0:msg}")
	 pr 	fmt.Printf("%${1:s}\n", ${2:var})
	 rn 	range ${0}
	 rt 	return ${0}
	 rs 	result
	 sl 	select {
	 sr 	string
	 st		struct ${1:name} {
	 sw 	switch ${1:var} {
	 sp 	fmt.Sprintf("%${1:s}", ${2:var})
	 t		true
	 g		go ${1:funcName}(${0})
	 ga 	go func(${1} ${2:type}) {
	 test	test function
	 bench	benchmark function
